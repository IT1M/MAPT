import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/services/prisma';
import { checkAuth, checkRole } from '@/middleware/auth';
import { handleApiError } from '@/utils/api-response';

/**
 * GET /api/settings/logs/export
 *
 * Export system logs for debugging and analysis
 * Only accessible to ADMIN users
 *
 * Requirements: 25.5
 */
export async function GET(request: NextRequest) {
  try {
    // Check authentication
    const authResult = await checkAuth();
    if ('error' in authResult) {
      return authResult.error;
    }

    const { context } = authResult;

    // Check user role (ADMIN only)
    const roleCheck = checkRole('ADMIN', context);
    if ('error' in roleCheck) {
      return roleCheck.error;
    }

    // Fetch recent audit logs (last 1000 entries)
    const auditLogs = await prisma.auditLog.findMany({
      take: 1000,
      orderBy: {
        timestamp: 'desc',
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            role: true,
          },
        },
      },
    });

    // Format logs as text
    const logLines: string[] = [
      '='.repeat(80),
      'SYSTEM LOGS EXPORT',
      `Generated: ${new Date().toISOString()}`,
      `Generated by: ${context.user.name} (${context.user.email})`,
      `Total entries: ${auditLogs.length}`,
      '='.repeat(80),
      '',
    ];

    // Add each log entry
    auditLogs.forEach((log, index) => {
      logLines.push(`[${index + 1}] ${log.timestamp.toISOString()}`);
      logLines.push(
        `User: ${log.user.name} (${log.user.email}) - Role: ${log.user.role}`
      );
      logLines.push(
        `Action: ${log.action} on ${log.entityType}${log.entityId ? ` (ID: ${log.entityId})` : ''}`
      );

      if (log.ipAddress) {
        logLines.push(`IP Address: ${log.ipAddress}`);
      }

      if (log.userAgent) {
        logLines.push(`User Agent: ${log.userAgent}`);
      }

      if (log.oldValue) {
        logLines.push(`Old Value: ${JSON.stringify(log.oldValue)}`);
      }

      if (log.newValue) {
        logLines.push(`New Value: ${JSON.stringify(log.newValue)}`);
      }

      logLines.push('-'.repeat(80));
      logLines.push('');
    });

    // Add system information
    logLines.push('');
    logLines.push('='.repeat(80));
    logLines.push('SYSTEM INFORMATION');
    logLines.push('='.repeat(80));

    // Get database statistics
    const userCount = await prisma.user.count();
    const inventoryCount = await prisma.inventoryItem.count();
    const reportCount = await prisma.report.count();
    const backupCount = await prisma.backup.count();

    logLines.push(`Total Users: ${userCount}`);
    logLines.push(`Total Inventory Items: ${inventoryCount}`);
    logLines.push(`Total Reports: ${reportCount}`);
    logLines.push(`Total Backups: ${backupCount}`);
    logLines.push('');

    // Get active users (logged in within last 24 hours)
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const recentAuditCount = await prisma.auditLog.count({
      where: {
        timestamp: {
          gte: oneDayAgo,
        },
      },
    });

    logLines.push(`Activity in last 24 hours: ${recentAuditCount} actions`);
    logLines.push('');

    // Get system settings
    const systemSettings = await prisma.systemSettings.findMany({
      orderBy: {
        category: 'asc',
      },
    });

    logLines.push('System Settings:');
    let currentCategory = '';
    systemSettings.forEach((setting) => {
      if (setting.category !== currentCategory) {
        currentCategory = setting.category;
        logLines.push(`\n[${currentCategory.toUpperCase()}]`);
      }

      // Mask sensitive values
      const sensitiveKeys = ['api_key', 'password', 'secret', 'token'];
      const isSensitive = sensitiveKeys.some((key) =>
        setting.key.toLowerCase().includes(key)
      );
      const value = isSensitive
        ? '***MASKED***'
        : JSON.stringify(setting.value);

      logLines.push(`  ${setting.key}: ${value}`);
    });

    logLines.push('');
    logLines.push('='.repeat(80));
    logLines.push('END OF LOGS');
    logLines.push('='.repeat(80));

    // Create text content
    const logContent = logLines.join('\n');

    // Return as downloadable file
    return new NextResponse(logContent, {
      status: 200,
      headers: {
        'Content-Type': 'text/plain',
        'Content-Disposition': `attachment; filename="system-logs-${new Date().toISOString().split('T')[0]}.txt"`,
      },
    });
  } catch (error) {
    return handleApiError(error);
  }
}
