/**
 * Universal Export Service
 * Supports CSV, Excel, PDF, and JSON exports with audit logging
 */

import * as XLSX from 'xlsx';
import Papa from 'papaparse';
import { prisma } from './prisma';
import { sendEmail } from './email';

export interface ExportOptions {
  format: 'csv' | 'excel' | 'pdf' | 'json';
  data: any[];
  columns?: string[];
  filename?: string;
  includeFilters?: boolean;
  metadata?: {
    title?: string;
    generatedBy?: string;
    dateRange?: string;
    filters?: Record<string, any>;
  };
}

export interface ExportResult {
  success: boolean;
  filename: string;
  fileSize: number;
  downloadUrl?: string;
  error?: string;
}

export interface ExportHistoryEntry {
  id: string;
  userId: string;
  format: string;
  recordCount: number;
  fileSize: number;
  filters?: Record<string, any>;
  createdAt: Date;
}

/**
 * Export data to CSV format with UTF-8 BOM for Excel compatibility
 */
export async function exportToCSV(options: ExportOptions): Promise<Buffer> {
  const { data, columns } = options;

  if (data.length === 0) {
    throw new Error('No data to export');
  }

  // Get headers from columns or data keys
  const headers =
    columns || Array.from(new Set(data.flatMap((item) => Object.keys(item))));

  // Create CSV content using papaparse
  const csv = Papa.unparse(data, {
    columns: headers,
    header: true,
  });

  // Add UTF-8 BOM for Excel compatibility
  const BOM = '\uFEFF';
  return Buffer.from(BOM + csv, 'utf-8');
}

/**
 * Export data to Excel format with formatting
 */
export async function exportToExcel(options: ExportOptions): Promise<Buffer> {
  const { data, metadata } = options;

  if (data.length === 0) {
    throw new Error('No data to export');
  }

  // Create workbook
  const workbook = XLSX.utils.book_new();

  // Create main data sheet
  const worksheet = XLSX.utils.json_to_sheet(data);

  // Add summary section at the top if metadata provided
  if (metadata) {
    const summaryRows = [
      [metadata.title || 'Data Export'],
      [`Generated: ${new Date().toLocaleString('en-US')}`],
      [`Generated By: ${metadata.generatedBy || 'System'}`],
      [`Total Records: ${data.length}`],
    ];

    if (metadata.dateRange) {
      summaryRows.push([`Date Range: ${metadata.dateRange}`]);
    }

    if (metadata.filters && Object.keys(metadata.filters).length > 0) {
      summaryRows.push([`Filters: ${JSON.stringify(metadata.filters)}`]);
    }

    summaryRows.push([]); // Empty row

    // Insert summary at the top
    XLSX.utils.sheet_add_aoa(worksheet, summaryRows, { origin: 'A1' });

    // Add data starting after summary
    const dataStartRow = summaryRows.length + 1;
    XLSX.utils.sheet_add_json(worksheet, data, {
      origin: `A${dataStartRow}`,
      skipHeader: false,
    });
  }

  // Auto-size columns
  const columnWidths = Object.keys(data[0] || {}).map((key) => ({
    wch:
      Math.max(
        key.length,
        ...data.map((row) => String(row[key] || '').length)
      ) + 2,
  }));
  worksheet['!cols'] = columnWidths;

  // Append worksheet to workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');

  // Generate Excel buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
  });
  return Buffer.from(excelBuffer);
}

/**
 * Export data to JSON format with metadata
 */
export async function exportToJSON(options: ExportOptions): Promise<Buffer> {
  const { data, metadata } = options;

  if (data.length === 0) {
    throw new Error('No data to export');
  }

  const jsonData = {
    metadata: {
      exportDate: new Date().toISOString(),
      totalRecords: data.length,
      generatedBy: metadata?.generatedBy || 'System',
      filters: metadata?.filters || {},
      ...metadata,
    },
    data,
  };

  const jsonString = JSON.stringify(jsonData, null, 2);
  return Buffer.from(jsonString, 'utf-8');
}

/**
 * Log export activity to audit trail
 */
export async function logExport(params: {
  userId: string;
  format: string;
  recordCount: number;
  fileSize: number;
  filters?: Record<string, any>;
  entity: string;
  entityId?: string;
}): Promise<void> {
  const { userId, format, recordCount, fileSize, filters, entity, entityId } =
    params;

  // Create audit log entry
  await prisma.auditLog.create({
    data: {
      userId,
      action: 'EXPORT',
      entity,
      entityId: entityId || 'export',
      changes: {
        format,
        recordCount,
        fileSize,
        filters: filters || {},
      },
      timestamp: new Date(),
    },
  });
}

/**
 * Get export history for a user
 */
export async function getExportHistory(
  userId: string,
  limit: number = 50
): Promise<ExportHistoryEntry[]> {
  const logs = await prisma.auditLog.findMany({
    where: {
      userId,
      action: 'EXPORT',
    },
    orderBy: {
      timestamp: 'desc',
    },
    take: limit,
  });

  return logs.map((log) => ({
    id: log.id,
    userId: log.userId,
    format: (log.changes as any).format || 'unknown',
    recordCount: (log.changes as any).recordCount || 0,
    fileSize: (log.changes as any).fileSize || 0,
    filters: (log.changes as any).filters,
    createdAt: log.timestamp,
  }));
}

/**
 * Send export file via email for large exports
 */
export async function emailExport(params: {
  to: string;
  userName: string;
  filename: string;
  fileBuffer: Buffer;
  format: string;
  recordCount: number;
}): Promise<void> {
  const { to, userName, filename, fileBuffer, format, recordCount } = params;

  const contentType =
    {
      csv: 'text/csv',
      excel:
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      pdf: 'application/pdf',
      json: 'application/json',
    }[format] || 'application/octet-stream';

  await sendEmail({
    to,
    subject: 'Your Export is Ready',
    template: 'export-ready',
    data: {
      userName,
      filename,
      recordCount,
      format: format.toUpperCase(),
      fileSize: (fileBuffer.length / 1024).toFixed(2) + ' KB',
    },
    attachments: [
      {
        filename,
        content: fileBuffer,
        contentType,
      },
    ],
  });
}

/**
 * Check if export should be emailed based on size
 */
export function shouldEmailExport(
  recordCount: number,
  threshold: number = 5000
): boolean {
  return recordCount > threshold;
}
